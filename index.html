<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四模式交互三状态传播系统</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #222;
            color: #eee;
            line-height: 1.4;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #ffd700;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }

        .simulation-section {
            flex: 3;
            min-width: 300px;
        }

        .controls-section {
            flex: 1;
            min-width: 250px;
        }

        canvas {
            background: #000;
            border: 2px solid #444;
            border-radius: 5px;
            display: block;
            width: 100%;
            height: auto;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            background: #333;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #ffd700;
        }

        .control-group {
            background: #333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
        }

        h2 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .slider-container {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            flex: 1;
            min-width: 100px;
            padding: 8px 12px;
            background: #555;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background: #666;
        }

        .btn-primary {
            background: #ffd700;
            color: #222;
        }

        .btn-danger {
            background: #ff4444;
        }

        .btn-active {
            background: #4CAF50 !important;
            color: white !important;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .mode-btn {
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
        }

        .mode-road {
            background: #666;
            border: 2px solid #888;
        }

        .mode-wall {
            background: #ff4444;
            border: 2px solid #ff6666;
        }

        .mode-yellow {
            background: #ffd700;
            color: #222;
            border: 2px solid #ffed4e;
        }

        .mode-eraser {
            background: #555;
            border: 2px solid #777;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        .road { background-color: #666; }
        .wall { background-color: #ff4444; }
        .yellow { background-color: #ffd700; }
        .dark-yellow { background-color: #b8860b; }
        .empty { background-color: #333; border: 1px solid #555; }

        .info {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        footer {
            text-align: center;
            margin-top: 20px;
            color: #888;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>四模式交互三状态传播系统</h1>
        </header>
        
        <div class="main-content">
            <section class="simulation-section">
                <canvas id="gridCanvas" width="800" height="600"></canvas>
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="yellowCount">0</div>
                        <div>黄色数量</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="cycleCount">0</div>
                        <div>时钟周期</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="fpsCounter">0</div>
                        <div>FPS</div>
                    </div>
                </div>
            </section>
            
            <section class="controls-section">
                <div class="control-group">
                    <h2>模式选择</h2>
                    <div class="mode-buttons">
                        <div class="mode-btn mode-road" id="roadModeBtn">
                            <div>路块模式</div>
                            <small>点击放置白色路块</small>
                        </div>
                        <div class="mode-btn mode-wall" id="wallModeBtn">
                            <div>墙块模式</div>
                            <small>点击放置红色墙块</small>
                        </div>
                        <div class="mode-btn mode-yellow" id="yellowModeBtn">
                            <div>黄色模式</div>
                            <small>点击放置黄色实例</small>
                        </div>
                        <div class="mode-btn mode-eraser" id="eraserModeBtn">
                            <div>橡皮擦模式</div>
                            <small>点击清除实体</small>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>模拟控制</h2>
                    <div class="slider-container">
                        <label for="speedSlider">模拟速度: <span id="speedValue">30</span> FPS</label>
                        <input type="range" id="speedSlider" min="1" max="60" value="30">
                    </div>
                    <div class="button-group">
                        <button id="startBtn" class="btn-primary">开始</button>
                        <button id="pauseBtn">暂停</button>
                        <button id="resetBtn" class="btn-danger">重置</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h2>图例</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color road"></div>
                            <span>路块</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color wall"></div>
                            <span>墙块</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color yellow"></div>
                            <span>黄色</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color dark-yellow"></div>
                            <span>深黄足迹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color empty"></div>
                            <span>空状态</span>
                        </div>
                    </div>
                </div>
            </section>
        </div>
        
        <div class="info">
            <h2>系统说明</h2>
            <p>基于三状态循环传播的简化模型：黄色 → 深黄足迹 → 空状态 → 黄色...</p>
            <p>黄色会向周围8个方向中的空路块传播，每个时钟周期状态推进一次。</p>
            <p><strong>操作说明：</strong></p>
            <ul>
                <li>选择"路块模式"：点击网格放置白色路块</li>
                <li>选择"墙块模式"：点击网格放置红色墙块（会清除所有覆盖状态）</li>
                <li>选择"黄色模式"：点击路块放置黄色实例</li>
                <li>选择"橡皮擦模式"：点击清除实体（墙块变回路块）</li>
            </ul>
            <p>墙块上不允许有任何覆盖状态，放置墙块时会自动清空该位置的状态。</p>
        </div>
        
        <footer>
            <p>四模式交互三状态传播系统 | 测试版本</p>
        </footer>
    </div>

    <script>
        // 系统常量
        const GRID_WIDTH = 40;
        const GRID_HEIGHT = 30;
        const CELL_SIZE = 20;
        
        // 状态枚举
        const STATE = {
            ROAD: 'road',
            WALL: 'wall',
            YELLOW: 'yellow',
            DARK_YELLOW: 'darkYellow',
            EMPTY: 'empty'
        };
        
        // 操作模式枚举
        const MODE = {
            ROAD: 'road',
            WALL: 'wall',
            YELLOW: 'yellow',
            ERASER: 'eraser'
        };
        
        // 方向偏移（8个方向）
        const DIRECTIONS = [
            {dx: -1, dy: -1}, {dx: 0, dy: -1}, {dx: 1, dy: -1},
            {dx: -1, dy: 0},                    {dx: 1, dy: 0},
            {dx: -1, dy: 1},  {dx: 0, dy: 1},  {dx: 1, dy: 1}
        ];
        
        // 系统状态
        let grid = []; // 二维数组，存储每个单元格的状态
        let isRunning = false;
        let cycleCount = 0;
        let fps = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let lastUpdateTime = 0;
        let currentMode = MODE.ROAD; // 当前操作模式
        
        // DOM元素
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const yellowCountEl = document.getElementById('yellowCount');
        const cycleCountEl = document.getElementById('cycleCount');
        const fpsCounterEl = document.getElementById('fpsCounter');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueEl = document.getElementById('speedValue');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        // 模式按钮
        const roadModeBtn = document.getElementById('roadModeBtn');
        const wallModeBtn = document.getElementById('wallModeBtn');
        const yellowModeBtn = document.getElementById('yellowModeBtn');
        const eraserModeBtn = document.getElementById('eraserModeBtn');
        
        // 初始化网格
        function initGrid() {
            grid = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // 边界设为墙，内部设为路
                    const isBorder = x === 0 || y === 0 || x === GRID_WIDTH - 1 || y === GRID_HEIGHT - 1;
                    
                    grid[y][x] = {
                        type: isBorder ? STATE.WALL : STATE.ROAD,
                        state: STATE.EMPTY // 初始为空状态
                    };
                }
            }
            
            // 在中心位置添加一个初始黄色
            const centerX = Math.floor(GRID_WIDTH / 2);
            const centerY = Math.floor(GRID_HEIGHT / 2);
            if (grid[centerY][centerX].type === STATE.ROAD) {
                grid[centerY][centerX].state = STATE.YELLOW;
            }
        }
        
        // 检查位置是否在网格内
        function isInBounds(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }
        
        // 检查位置是否是空路块
        function isEmptyRoad(x, y) {
            return isInBounds(x, y) && 
                   grid[y][x].type === STATE.ROAD && 
                   grid[y][x].state === STATE.EMPTY;
        }
        
        // 获取周围空路块的位置
        function getEmptyNeighbors(x, y) {
            const neighbors = [];
            for (const dir of DIRECTIONS) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;
                if (isEmptyRoad(nx, ny)) {
                    neighbors.push({x: nx, y: ny});
                }
            }
            return neighbors;
        }
        
        // 清空指定位置的状态（墙块放置时调用）
        function clearCellState(x, y) {
            if (isInBounds(x, y)) {
                grid[y][x].state = STATE.EMPTY;
            }
        }
        
        // 更新模拟逻辑
        function updateSimulation() {
            // 创建下一状态的网格
            const nextGrid = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                nextGrid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // 复制基本类型（路/墙不变）
                    nextGrid[y][x] = {
                        type: grid[y][x].type,
                        state: grid[y][x].state
                    };
                    
                    // 墙块上的状态始终为空
                    if (grid[y][x].type === STATE.WALL) {
                        nextGrid[y][x].state = STATE.EMPTY;
                    }
                }
            }
            
            // 第一阶段：处理黄色状态
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // 只处理路块上的黄色状态
                    if (grid[y][x].type === STATE.ROAD && grid[y][x].state === STATE.YELLOW) {
                        // 黄色状态：查找周围空路块，向它们传播
                        const emptyNeighbors = getEmptyNeighbors(x, y);
                        
                        if (emptyNeighbors.length > 0) {
                            // 向所有空邻居传播黄色
                            for (const neighbor of emptyNeighbors) {
                                // 确保邻居是路块且为空状态
                                if (nextGrid[neighbor.y][neighbor.x].type === STATE.ROAD) {
                                    nextGrid[neighbor.y][neighbor.x].state = STATE.YELLOW;
                                }
                            }
                        }
                        
                        // 黄色变为深黄足迹
                        nextGrid[y][x].state = STATE.DARK_YELLOW;
                    }
                }
            }
            
            // 第二阶段：处理深黄足迹状态
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x].state === STATE.DARK_YELLOW) {
                        // 深黄足迹变为空状态
                        nextGrid[y][x].state = STATE.EMPTY;
                    }
                }
            }
            
            // 更新网格
            grid = nextGrid;
            cycleCount++;
        }
        
        // 统计黄色数量
        function countYellows() {
            let count = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x].state === STATE.YELLOW) {
                        count++;
                    }
                }
            }
            return count;
        }
        
        // 绘制网格
        function draw() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制每个单元格
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = grid[y][x];
                    const px = x * CELL_SIZE;
                    const py = y * CELL_SIZE;
                    
                    // 绘制基本类型
                    if (cell.type === STATE.WALL) {
                        ctx.fillStyle = '#ff4444';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    } else {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
                    }
                    
                    // 绘制覆盖状态（墙块上不绘制覆盖状态）
                    if (cell.type === STATE.ROAD) {
                        if (cell.state === STATE.YELLOW) {
                            ctx.fillStyle = '#ffd700';
                            ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                        } else if (cell.state === STATE.DARK_YELLOW) {
                            ctx.fillStyle = '#b8860b';
                            ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                        } else if (cell.state === STATE.EMPTY) {
                            // 空路块用深色表示
                            ctx.fillStyle = '#333';
                            ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                        }
                    }
                    
                    // 绘制网格线
                    ctx.strokeStyle = '#444';
                    ctx.strokeRect(px, py, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        
        // 主循环
        function mainLoop(currentTime) {
            frameCount++;
            
            // 更新FPS显示
            if (currentTime - lastFpsUpdate >= 1000) {
                fps = frameCount * 1000 / (currentTime - lastFpsUpdate);
                lastFpsUpdate = currentTime;
                frameCount = 0;
                fpsCounterEl.textContent = Math.round(fps);
            }
            
            // 更新模拟逻辑
            if (isRunning) {
                const speed = parseInt(speedSlider.value);
                const updateInterval = 1000 / speed;
                
                if (currentTime - lastUpdateTime >= updateInterval) {
                    updateSimulation();
                    lastUpdateTime = currentTime;
                    
                    // 更新统计
                    yellowCountEl.textContent = countYellows();
                    cycleCountEl.textContent = cycleCount;
                }
            }
            
            // 绘制
            draw();
            
            // 继续循环
            requestAnimationFrame(mainLoop);
        }
        
        // 设置当前操作模式
        function setMode(mode) {
            currentMode = mode;
            
            // 更新按钮状态
            roadModeBtn.classList.remove('btn-active');
            wallModeBtn.classList.remove('btn-active');
            yellowModeBtn.classList.remove('btn-active');
            eraserModeBtn.classList.remove('btn-active');
            
            // 激活当前模式按钮
            if (mode === MODE.ROAD) {
                roadModeBtn.classList.add('btn-active');
            } else if (mode === MODE.WALL) {
                wallModeBtn.classList.add('btn-active');
            } else if (mode === MODE.YELLOW) {
                yellowModeBtn.classList.add('btn-active');
            } else if (mode === MODE.ERASER) {
                eraserModeBtn.classList.add('btn-active');
            }
        }
        
        // 处理网格点击
        function handleGridClick(x, y) {
            if (!isInBounds(x, y)) return;
            
            // 边界不允许修改
            const isBorder = x === 0 || y === 0 || x === GRID_WIDTH - 1 || y === GRID_HEIGHT - 1;
            if (isBorder && currentMode !== MODE.ERASER) return;
            
            switch (currentMode) {
                case MODE.ROAD:
                    // 放置路块
                    if (grid[y][x].type !== STATE.ROAD) {
                        grid[y][x].type = STATE.ROAD;
                        grid[y][x].state = STATE.EMPTY;
                    }
                    break;
                    
                case MODE.WALL:
                    // 放置墙块，同时清空状态
                    grid[y][x].type = STATE.WALL;
                    grid[y][x].state = STATE.EMPTY;
                    break;
                    
                case MODE.YELLOW:
                    // 放置黄色实例（只能在路块上放置）
                    if (grid[y][x].type === STATE.ROAD) {
                        grid[y][x].state = STATE.YELLOW;
                    }
                    break;
                    
                case MODE.ERASER:
                    // 橡皮擦模式
                    if (isBorder) {
                        // 边界只能清除状态，不能改变类型
                        grid[y][x].state = STATE.EMPTY;
                    } else {
                        // 非边界可以清除状态，墙块变回路块
                        grid[y][x].type = STATE.ROAD;
                        grid[y][x].state = STATE.EMPTY;
                    }
                    break;
            }
        }
        
        // 事件监听器
        startBtn.addEventListener('click', () => {
            isRunning = true;
            startBtn.disabled = true;
            pauseBtn.disabled = false;
        });
        
        pauseBtn.addEventListener('click', () => {
            isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
        });
        
        resetBtn.addEventListener('click', () => {
            isRunning = false;
            cycleCount = 0;
            initGrid();
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            yellowCountEl.textContent = countYellows();
            cycleCountEl.textContent = cycleCount;
        });
        
        // 模式按钮事件
        roadModeBtn.addEventListener('click', () => setMode(MODE.ROAD));
        wallModeBtn.addEventListener('click', () => setMode(MODE.WALL));
        yellowModeBtn.addEventListener('click', () => setMode(MODE.YELLOW));
        eraserModeBtn.addEventListener('click', () => setMode(MODE.ERASER));
        
        speedSlider.addEventListener('input', () => {
            speedValueEl.textContent = speedSlider.value;
        });
        
        // 点击网格事件
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) * scaleY / CELL_SIZE);
            
            handleGridClick(x, y);
        });
        
        // 鼠标拖拽绘制
        let isDrawing = false;
        
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) * scaleY / CELL_SIZE);
            
            handleGridClick(x, y);
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / CELL_SIZE);
            const y = Math.floor((e.clientY - rect.top) * scaleY / CELL_SIZE);
            
            handleGridClick(x, y);
        });
        
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });
        
        // 初始化
        function init() {
            initGrid();
            
            // 设置初始模式
            setMode(MODE.ROAD);
            
            // 设置初始按钮状态
            pauseBtn.disabled = true;
            
            // 更新初始统计
            yellowCountEl.textContent = countYellows();
            cycleCountEl.textContent = cycleCount;
            speedValueEl.textContent = speedSlider.value;
            
            // 启动主循环
            requestAnimationFrame(mainLoop);
        }
        
        // 启动系统
        init();
    </script>
</body>
</html>